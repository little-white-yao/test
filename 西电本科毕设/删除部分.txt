原始点云中的点被划分到不同的节点的实现过程如下:

1.首先将所有的点根据莫顿码的第1个八进制数$m_{K-1}^{n}$的取值分到八个子节点中 ：
\begin{itemize}
    \item 所有$m_{K-1}^{n}=0$的点，分配到第0个子节点$N_{0}^{1}$中;
    \item 所有$m_{K-1}^{n}=1$的点，分配到第1个子节点$N_{1}^{1}$中;
    \item $\mathbf{\ldots\ldots}$;
    \item 所有$m_{K-1}^{n}=7$的点，分配到第7个子节点$N_{7}^{1}$中;
\end{itemize}
至此点云中所有的点凭借莫顿码的第一个八进制数都被划分至根节点的八个子节点中，八叉树的第一层划分结束。

2. 用八比特$B_{0}^{0}=(b_0b_1b_2b_3b_4b_5b_6b_7)$来表示根节点$N_0^0$的八个子节点是否被占用。如果子节点至少包含点云中的一个点，那么该子节点对应的占位比特$b_k$取1。如果该子节点不包含任何点，那么占位比特$b_k$取0。

3.根据几何位置的莫顿码的第2个八进制数$m_{K-2}^n$，对第一层中被占用的节点进一步进行划分。将每个节点中的点按照其莫顿码第二个八进制数的取值在该节点中选取自己被划分到的子节点，并继续使用八个比特表示节点的八个子节点的占用信息；而不占用的节点也就意味着该子节点不包含点，停止划分。

4.再根据莫顿码中的第$t$个八进制数$m_{K-t}^n$，对第$t=3, \ldots, K-3$层中被占用的节点进一步划分成八个子节点；并用八个比特表示将其子节点的占用信息。

5.对第$t=K$层，所有的节点成为叶子节点，此时点云模型被划分至体素级别，即划分出的叶子节点边长为1，无法继续划分，八叉树划分到此结束。

由于经过量化后一个节点内的不同点可能会重合成一个点，这时编码端会将重复点个数送入熵编码器，解码端通过算数解码得到。因此解码端在重建八叉树时，能够无损恢复每个节点中真实点的个数。





Trisoup几何信息编码算法的基本思想是将编码八叉树划分到一定层次后的叶子节点中数量较多的原始点云信息压缩成了编码该叶子节点边上的顶点信息，其中顶点信息包括叶子节点的每条边是否被占据以及被占据边上顶点的位置信息，解码端在获取到编码生成的bit流后，按照标准进行解码操作，然后进行点云重建。当然，在实际编码过程中还对很多其他辅助信进行了编码，比如：质心坐标值、质心偏移值以及上层参数值。这样的操作虽然大大减少了需要编码的信息量，但是由于在



\begin{figure}[htbp]
    %是可选项 h表示的是here在这里插入，t表示的是在页面的顶部插入
    \centering
    \includegraphics[scale=0.4]{image/区间划分示意图.png}
    \caption{边的区间划分示意图}
    \label{fig:边的区间划分}
\end{figure}
\begin{figure}[htbp]
    %是可选项 h表示的是here在这里插入，t表示的是在页面的顶部插入
    \centering
    \includegraphics[scale=0.4]{image/当前待编码边周围节点.png}
    \caption{当前待编码边周围节点示意图}
    \label{fig:当前待编码边周围节点}
\end{figure}